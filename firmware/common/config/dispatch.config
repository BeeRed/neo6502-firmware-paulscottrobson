// ***************************************************************************************
// ***************************************************************************************
//
//      Name :      dispatch.config
//      Authors :   Paul Robson (paul@robsons.org.uk)
//      Date :      22nd November 2023
//      Reviewed :  No
//      Purpose :   Dispatched for commands
//
// ***************************************************************************************
// ***************************************************************************************


// ***************************************************************************************
// Notes regarding the format of this document:
//
// This document is an input to makedispatch.py,
// which generates the C header file for commands dispatch ('dispatch_code.h'),
// and the LaTeX documentation source file ('api.texi') for the API.
// The parser injects tables and table rows into the template 'api.texi.in',
// based on entries in this file; and injects the 'mtime' of this file as the date.
//
// All "tokens" described below are assumed to be white-space delimited
// ("immediately followed by") implies some white-space separation.
// The special tokens 'GROUP', 'FUNCTION', and 'DOCUMENTATION'
// must be the first token on its line, and must be upper-case.
//
// The 'GROUP' tokens must be immediately followed by an Group index number.
// That number may be followed optionally by a CSV list of Function indices
// which should have a page-break inserted before them. If present, the list must
// begin with a comma, contain no spaces, and immediately follow the index number.
// The Function tables will not automatically span multiple pages.
// As new data is added, the table may become too large to fit on one page,
// will "float" to an unintended position in the document, and will not print correctly.
// There is a plugin which can manage page-breaks within tables, but it is not used.
// These page-breaks will need to be adjusted manually, as table rows or cell contents
// are added or removed, to ensure that each table fits optimally on one page.
// If no Function is defined at a specified index, the page-break will be inserted
// before the Function at the next greatest index.
// The index number or the page-breaks list (if present) may be followed
// optionally by a formal name for the Group, which may include spaces.
// If a page-breaks list is absent, the Group Name must not begin with a comma.
//
// The 'FUNCTION' tokens must be immediately followed by a Function index number.
// That number may be followed optionally by a formal name for the Function.
// The Function name may include spaces.
// If present, the Group and Function names will be used in the table headers.
// Lines following 'FUNCTION' tokens are output to the C header file verbatim.
//
// Lines following 'DOCUMENTATION' tokens will be processed by a TeX compiler.
// There are a few caveats to be aware of. If the TeX parser fails, it is
// probably a character in this file which is being misinterpreted.
// Try to avoid special characters, especially underscore and back-slash.
// All white-space is consolidated (HTML-style). Use LaTeX for special formatting.
// Most LaTeX syntax will be processed properly; though contrary to LaTeX syntax,
// dollar symbols must _not_ be escaped. The python parser handles those.
//
// ***************************************************************************************


include defines.config.inc


// ***************************************************************************************
//
// Group 1 (System)
//
// ***************************************************************************************

GROUP 1 System
    FUNCTION 0 Reset
        DSPReset();
    DOCUMENTATION
        Resets the messaging system and component systems.
        Normally, should not be used.

    FUNCTION 1 Timer
        *((uint32_t *)DPARAMS) = TMRRead(); // (assumes littleendian)
    DOCUMENTATION
        Deposit the value (32-bits) of the 100Hz system timer into \Param{0..3}.

    FUNCTION 2 Key Status
        i1 = *DPARAMS;
        *DPARAMS = (i1 < KBD_MAX_KEYCODE) ? KBDGetStateArray()[i1] : 0;
    DOCUMENTATION
        Deposit the state of the specified keyboard key into \Param{0}.
        The key which to query is specified in \Param{0}.

    FUNCTION 3 Basic
        MEMLoadBasic();
    DOCUMENTATION
        Execute BASIC (loading currently does not work).

    FUNCTION 4 Credits
        CONWriteString((char *)whoList);
    DOCUMENTATION
        Print the Neo6502 project contributors (stored in flash memory).

    FUNCTION 5 Serial Status
        SERCheckDataAvailable();
    DOCUMENTATION
        Check the serial port to see if there is a data transmission.
        Group 2 Function 1 "Read Character" does this implicitly.

    FUNCTION 6 Locale
        LOCSetLocale(DPARAMS[0],DPARAMS[1]);
    DOCUMENTATION
        Set the locale code specified in \Param{0,1} as upper-case ASCII letters.
        \Param{0} takes the first letter and \Param{1} takes the second letter.
        For example:
        \begin{description}
        \item English:\MonoSp{~\Param{0}\textless-$45} ('E') and \MonoSp{\Param{1}\textless-$4E} ('N')
        \item French:\MonoSp{~~\Param{0}\textless-$46} ('F') and \MonoSp{\Param{1}\textless-$52} ('R')
        \end{description}

    FUNCTION 7 System Reset
        ResetSystem();
    DOCUMENTATION
        System Reset


// ***************************************************************************************
//
// Group 2 (Console)
//
// ***************************************************************************************

GROUP 2 ,0,8 Console
    FUNCTION 0 Write Character
        CONWrite(*DPARAMS);
    DOCUMENTATION
      Function 0 is console out (duplicate of Function 6 for backward compatibility).

    FUNCTION 1 Read Character
        *(DPARAMS) = KBDGetKey();
    DOCUMENTATION
        Read and remove a key press from the keyboard queue into \Param{0}.
        This is the ASCII value of the keystroke.
        If there are no key presses in the queue, \Param{0} will be zero.
        \newline
        Note that this Function is best for text input, but not for games.
        Function 7,1 is more optimal for games.

    FUNCTION 2 Console Status
        *(DPARAMS) = KBDIsKeyAvailable() ? 0xFF: 0;
    DOCUMENTATION // Function 2 is key available in queue
        Check to see if the keyboard queue is empty.
        If it is, \Param{0} will be \MonoSp{$FF}, otherwise it will be \MonoSp{$00}.

    FUNCTION 3 Read Line
        CONGetScreenLine(DSPGetInt16(DCOMMAND,4));
    DOCUMENTATION
        Input the current line below the cursor into YX as a length-prefixed string;
        and move the cursor to the line below. Handles multiple-line input.

    FUNCTION 4 Define Hotkey
        *DERROR = KBDSetFunctionKey(*(DCOMMAND+4),DSPGetString(DCOMMAND,6));
    DOCUMENTATION
        Define the function key F1..F10 (\MonoSp{$01..$0A}) specified in \Param{0} to emit the
        length-prefixed string stored at the memory location specified in \Param{2,3}.
        For example, in a block of in-line assembly within a BASIC program,
        the string: \MonoSp{06,12,108,105,115,116,13} would clear the screen (\MonoSp{12}),
        then list the program (\MonoSp{108}='l',\MonoSp{105}='i',\MonoSp{115}='s',\MonoSp{116}='t',\MonoSp{13}='ENTER').

    FUNCTION 5 Define Character
        *DERROR = CONUpdateUserFont(DPARAMS);
    DOCUMENTATION
        Define a font character specified in \Param{0} within the range of 192..255.
        Fill bits 0..5 (columns) of \Param{1..7} (rows) with the character bitmap.

    FUNCTION 6 Write Character
        CONWrite(*DPARAMS);
    DOCUMENTATION
        Write the character specified in \Param{0} to the console at the cursor position.
        Refer to Section \#\ref{console-codes} "Console Codes" for details.

    FUNCTION 7 Set Cursor Pos
        *DERROR = CONSetCursorPosition(DPARAMS[0],DPARAMS[1]);
    DOCUMENTATION
        Move the cursor to the screen character cell \Param{0}\textless-X, \Param{1}\textless-Y.

    FUNCTION 8 List Hotkeys
        KBDShowFunctionKeys();
    DOCUMENTATION
        Display the current function key definitions.

    FUNCTION 9 Screen Size
        CONGetScreenSizeChars(&DPARAMS[0],&DPARAMS[1]);
    DOCUMENTATION
        Fetches the screen size, in chars.
        \newline TODO: explain this function and any parameters

    FUNCTION 10 Insert Line
        CONInsertLine(DPARAMS[0]);
    DOCUMENTATION
        Insert Line
        \newline TODO: explain this function and any parameters

    FUNCTION 11 Delete Line
        CONDeleteLine(DPARAMS[0]);
    DOCUMENTATION
        Delete Line
        \newline TODO: explain this function and any parameters

    FUNCTION 12 Clear Screen
        CONClearScreen();
    DOCUMENTATION
        Clears the screen.

    FUNCTION 13 Cursor Position
        CONGetCursorPosition(&DPARAMS[0],&DPARAMS[1]);
    DOCUMENTATION
        Get Cursor Position
        \newline TODO: explain this function and any parameters

    FUNCTION 14 Clear Region
        CONClearArea(DPARAMS[0],DPARAMS[1],DPARAMS[2],DPARAMS[3]);
    DOCUMENTATION
        Erase all characters within the rectangular region specified
        in \Param{0,1} (begin X,Y) and \Param{2,3} (end X,Y).

    FUNCTION 15 Set Text Color
        CONSetForeBackColour(DPARAMS[0],DPARAMS[1]);
    DOCUMENTATION
        Set Text Color
        \newline TODO: explain this function and any parameters

    FUNCTION 16 Cursor Inverse
        CONReverseCursorBlock();
    DOCUMENTATION
        Toggles the cursor colour between normal and inverse
        (ie: swaps FG and BG colors).


// ***************************************************************************************
//
// Group 3 (File I/O)
//
// ***************************************************************************************

GROUP 3 ,0,9 File I/O
    FUNCTION 1 List Directory
        FIODirectory("");
    DOCUMENTATION
        Display the file listing of the present directory.

    FUNCTION 2 Load File
        *DERROR = FIOReadFile(DSPGetStdString(DCOMMAND,4),DSPGetInt16(DCOMMAND,6),DCOMMAND);
    DOCUMENTATION
        Load a file by name, per the length-prefixed string stored at the memory location
        specified in \Param{0,1} into to the memory location specified in \Param{2,3}.
        When the command completes, an error/status code will be in \Param{0}.
        If the address in \Param{2,3} is \MonoSp{$FFFF}, the file will be loaded into the
        graphics working memory, used for sprites, tiles, images.

    FUNCTION 3 Store File
        *DERROR = FIOWriteFile(DSPGetStdString(DCOMMAND,4),DSPGetInt16(DCOMMAND,6),DSPGetInt16(DCOMMAND,8));
    DOCUMENTATION
        Save the data stored at the memory location specified in \Param{2,3} to storage,
        as a file with the specified filename, per the length-prefixed string
        stored at the memory location specified in \Param{0,1}.
        \Param{4,5} specify the number of bytes to store.
        When the command completes, an error/status code will be in \Param{0}.

    FUNCTION 4 File Open
        *DERROR = FIOOpenFileHandle(DPARAMS[0],DSPGetStdString(DPARAMS,1),DPARAMS[3]);
    DOCUMENTATION
        File Open
        \newline TODO: explain this function and any parameters

    FUNCTION 5 File Close
        *DERROR = FIOCloseFileHandle(DPARAMS[0]);
    DOCUMENTATION
        File Close
        \newline TODO: explain this function and any parameters

    FUNCTION 6 File Seek
        *DERROR = FIOSeekFileHandle(DPARAMS[0],DSPGetInt32(DPARAMS,1));
    DOCUMENTATION
        File Seek
        \newline TODO: explain this function and any parameters

    FUNCTION 7 File Tell
    {
        uint32_t pos;
        *DERROR = FIOTellFileHandle(DPARAMS[0],&pos);
        DSPSetInt32(DPARAMS,1,pos);
    }
    DOCUMENTATION
        Deposits the current seek position (byte-offset) into \Param{4}.

    FUNCTION 8 File Read
    {
        uint16_t size = DSPGetInt16(DPARAMS,3);
        *DERROR = FIOReadFileHandle(DPARAMS[0],DSPGetInt16(DPARAMS,1),&size);
        DSPSetInt16(DPARAMS,3,size);
    }
    DOCUMENTATION
        File Read
        \newline TODO: explain this function and any parameters

    FUNCTION 9 File Write
    {
        uint16_t size = DSPGetInt16(DPARAMS,3);
        *DERROR = FIOWriteFileHandle(DPARAMS[0],DSPGetInt16(DPARAMS,1),&size);
        DSPSetInt16(DPARAMS,3,size);
    }
    DOCUMENTATION
        File Write
        \newline TODO: explain this function and any parameters

    FUNCTION 10 File Size
    {
        uint32_t size;
        *DERROR = FIOGetSizeFileHandle(DPARAMS[0],&size);
        DSPSetInt32(DPARAMS,1,size);
    }
    DOCUMENTATION
        File Size
        \newline TODO: explain this function and any parameters

    FUNCTION 11 File Set Size
    {
        *DERROR = FIOSetSizeFileHandle(DPARAMS[0],DSPGetInt32(DPARAMS,1));
    }
    DOCUMENTATION
        File Set Size
        \newline TODO: explain this function and any parameters

    FUNCTION 12 File Rename
    {
        *DERROR = FIORenameFile(DSPGetStdString(DPARAMS, 0), DSPGetStdString(DPARAMS, 2));
    }
    DOCUMENTATION
        File Rename
        \newline TODO: explain this function and any parameters

    FUNCTION 13 Delete File
    {
        *DERROR = FIODeleteFile(DSPGetStdString(DPARAMS, 0));
    }
    DOCUMENTATION
        Delete File
        \newline TODO: explain this function and any parameters

    FUNCTION 14 Create Directory
    {
        *DERROR = FIOCreateDirectory(DSPGetStdString(DPARAMS, 0));
    }
    DOCUMENTATION
        Create Directory
        \newline TODO: explain this function and any parameters

    FUNCTION 15 Change Directory
        {
        *DERROR = FIOChangeDirectory(DSPGetStdString(DPARAMS, 0));
        }
    DOCUMENTATION
        Change Directory
        \newline TODO: explain this function and any parameters

    FUNCTION 16 Stat File
    {
        uint32_t length;
        uint8_t type;
        *DERROR = FIOStatFile(DSPGetStdString(DPARAMS, 0), &length, &type);
        DSPSetInt32(DPARAMS, 0, length);
        DPARAMS[4] = type;
    }
    DOCUMENTATION
        Stat File
        \newline TODO: explain this function and any parameters

    FUNCTION 17 Open Directory
    {
        *DERROR = FIOOpenDir(DSPGetStdString(DPARAMS, 0));
    }
    DOCUMENTATION
        Open Directory
        \newline TODO: explain this function and any parameters

    FUNCTION 18 Read Directory
        {
        std::string filename;
        uint32_t size;
        uint8_t attribs;
        *DERROR = FIOReadDir(filename, &size, &attribs);
        DSPSetStdString(DPARAMS, 0, filename);
        DSPSetInt32(DPARAMS, 2, size);
        DPARAMS[6] = attribs;
        }
    DOCUMENTATION
        Read Directory
        \newline TODO: explain this function and any parameters

    FUNCTION 19 Close Directory
        {
            *DERROR = FIOCloseDir();
        }
    DOCUMENTATION
        Close Directory
        \newline TODO: explain this function and any parameters

    FUNCTION 20 Copy File
        *DERROR = FIOCopyFile(DSPGetStdString(DPARAMS, 0), DSPGetStdString(DPARAMS, 2));
    DOCUMENTATION
        Copy File
        \newline TODO: explain this function and any parameters

    FUNCTION 32 List Filtered
        FIODirectory(DSPGetString(DCOMMAND,4));
    DOCUMENTATION
        Display the file listing of the present directory,
        filtered per the length-prefixed string
        stored at the memory location specified in \Param{0,1}.


// ***************************************************************************************
//
// Group 4 (Mathematics)
//
// ***************************************************************************************

GROUP 4 ,0,20 Mathematics
    include maths_binary.config.inc
    include maths_unary.config.inc
    include maths_other.config.inc


// ***************************************************************************************
//
// Group 5 (Graphics)
//
// ***************************************************************************************

GROUP 5 ,0,5 Graphics
    FUNCTION 1 Set Defaults
        GFXSetDefaults(DCOMMAND);
    DOCUMENTATION
        Configure the global graphics system settings.
        Not all parameters are relevant for all graphics commands;
        but all parameters will be set by this command. So mind their values.
        Refer to Section \#\ref{subsec:graphics-settings} "Graphics Settings" for details.
        \newline
        \ParamsBytes{Graphics Settings}{AND}{XOR}{Fill}{Extent}
                                       {Flip}{unused}{\textit{unused}}{\textit{unused}}
        \newline
        \ParamBits{$FF08 - Flip Axis Flags}{0}{0}{0}{0}{0}{0}{Vertical}{Horizontal}

    FUNCTION 2 Draw Line
        GFXGraphicsCommand(2,DCOMMAND);
    DOCUMENTATION
        Draw a line between the screen coordinates specified
        in  \Param{0,1},\Param{2,3} (begin X,Y)
        and \Param{4,5},\Param{6,7} (end X,Y).
        \newline
        \ParamsBytes{Draw Line Parameters}{X  lo}{X  hi}{Y  lo}{Y  hi}
                                          {X' lo}{X' hi}{Y' lo}{Y' hi}

    FUNCTION 3 Draw Rectangle
        GFXGraphicsCommand(3,DCOMMAND);
    DOCUMENTATION
        Draw a rectangle spanning the screen coordinates specified
        in  \Param{0,1},\Param{2,3} (corner X,Y)
        and \Param{4,5},\Param{6,7} (opposite corner X,Y).

    FUNCTION 4 Draw Elipse
        GFXGraphicsCommand(4,DCOMMAND);
    DOCUMENTATION
        Draw an ellipse spanning the screen coordinates specified
        in  \Param{0,1},\Param{2,3} (corner  X,Y)
        and \Param{4,5},\Param{6,7} (opposite corner X,Y).

    FUNCTION 5 Draw Pixel
        GFXGraphicsCommand(5,DCOMMAND);
    DOCUMENTATION
        Draw a single pixel at the screen coordinates specified
        in \Param{0,1},\Param{2,3} (X,Y).

    FUNCTION 6 Draw Text
        GFXGraphicsCommand(6,DCOMMAND);
    DOCUMENTATION
        Draw the length-prefixed string of text stored
        at the memory location specified in \Param{4,5}
        at the screen character cell specified in \Param{0,1},\Param{2,3} (X,Y).

    FUNCTION 7 Draw Image
        GFXGraphicsCommand(7,DCOMMAND);
    DOCUMENTATION
        Draw the image with image ID in \Param{4}
        at the screen coordinates \Param{0,1},\Param{2,3} (X,Y).
        The extent and flip settings influence this command.

    FUNCTION 8 Draw Tilemap
        *DERROR = TMPDrawTileMap(DCOMMAND);
    DOCUMENTATION
        Draw the current tilemap at the screen coordinates specified
        in \Param{0,1},\Param{2,3} (top-left X,Y)
        and \Param{4,5},\Param{6,7} (bottom-right X,Y)
        using current graphics settings.

    FUNCTION 32 Set Palette
        gMode.setPalette(DPARAMS[0],DPARAMS[1],DPARAMS[2],DPARAMS[3]);
    DOCUMENTATION
        Set the palette colour at the index spcified in \Param{0}
        to the values in \Param{1},\Param{2},\Param{3} (RGB).

    FUNCTION 33 Read Pixel
        GFXGraphicsCommand(33,DCOMMAND);
    DOCUMENTATION
        Read a single pixel at the screen coordinates specified
        in \Param{0,1},\Param{2,3} (X,Y).
        When the routine completes, the result will be in \Param{0}.

    FUNCTION 34 Reset Palette
        GFXDefaultPalette();
    DOCUMENTATION
        Reset the palette to the defaults.

    FUNCTION 35 Set Tilemap
        TMPSelectTileMap(cpuMemory+DSPGetInt16(DCOMMAND,4),DSPGetInt16(DCOMMAND,6),DSPGetInt16(DCOMMAND,8));
    DOCUMENTATION
        Set the current tilemap.
        \Param{0,1} is the memory address of the tilemap,
        and \Param{2,3},\Param{4,5} (X,Y) specifies the offset into the tilemap,
        in units of pixels, of the top-left pixel of the tile.

    FUNCTION 36 Read Sprite Pixel
        GFXGraphicsCommand(36,DCOMMAND);
    DOCUMENTATION
        Read Pixel from the sprite layer at the screen coordinates
        specified in \Param{0,1},\Param{2,3} (X,Y).
        When the routine completes, the result will be in \Param{0}.
        Refer to Section \#\ref{graphics-colors} "Pixel Colors" for details.

    FUNCTION 37 Frame Count
        *((uint32_t *)DPARAMS) = RNDGetFrameCount();
    DOCUMENTATION
        Deposit into \Param{0..3},
        the number of v-blanks (full screen redraws) which have occurred since power-on.
        This is updated at the start of each v-blank period.

    FUNCTION 64 Set Color
        GFXSetDrawColour(DPARAMS[0]);
    DOCUMENTATION
        Set Color
        \newline TODO: explain this function and any parameters

    FUNCTION 65 Set Solid Flag
        GFXSetSolidFlag(DPARAMS[0]);
    DOCUMENTATION
        Set Solid Flag
        \newline TODO: explain this function and any parameters

    FUNCTION 66 Set Draw Size
        GFXSetDrawSize(DPARAMS[0]);
    DOCUMENTATION
        Set Draw Size
        \newline TODO: explain this function and any parameters

    FUNCTION 67 Set Flip Bits
        GFXSetFlipBits(DPARAMS[0]);
    DOCUMENTATION
        Set Flip Bits
        \newline TODO: explain this function and any parameters


// ***************************************************************************************
//
// Group 6 (Sprites)
//
// ***************************************************************************************

GROUP 6 ,0 Sprites
    FUNCTION 1 Sprite Reset
        SPRReset();
    DOCUMENTATION
        Reset the sprite system.

    FUNCTION 2 Sprite Set
        *DERROR = SPRUpdate(DPARAMS);
    DOCUMENTATION
        Set or update the sprite specified in \Param{0}.
        \newline
        \ParamsBytes{Sprite Parameters}{Sprite}{X lo}{X hi}{Y lo}{Y hi}{Image}{Flip}{Anchor}
        \newline
        \SpriteParamBits{$FF09 - Image Parameters}{0}{32-bit}{Index}
        \newline
        \ParamBits{$FF0A - Flip Axis Flags}{0}{0}{0}{0}{0}{0}{Vertical}{Horizontal}

    FUNCTION 3 Sprite Hide
        SPRHide(DPARAMS);
    DOCUMENTATION
        Hide the sprite specified in \Param{0}.

    FUNCTION 4 Sprite Collision
        DPARAMS[0] = SPRCollisionCheck(DERROR,DPARAMS[0],DPARAMS[1],DPARAMS[2]);
    DOCUMENTATION
        \Param{0} is non-zero if the distance is less than or equal to \Param{2}
        between the center of the sprite with index specified in \Param{0}
        and the center of the sprite with index specified in \Param{1} .

    FUNCTION 5 Sprite Position
        *DERROR = SPRGetSpriteData(DPARAMS);
    DOCUMENTATION
        Deposit into \Param{1..4}, the screen coordinates of the sprite
        with the index specified in \Param{0}.


// ***************************************************************************************
//
// Group 7 (Controller)
//
// ***************************************************************************************

GROUP 7 ,0 Controller
    FUNCTION 1 Read Controller
        *DPARAMS = KBDKeyboardController();
    DOCUMENTATION
        Read the state of keyboard, joystick, etc.
        Initially, the Controller is the keyboard.
        This Function interprets key presses and releases as a joystick.
        The system maintains a bit-array of which keys are pressed.
        Currently, the keyboard is the only available Controller.
        \newline
        \ParamBits{$FF04 - Controller Flags}{0}{0}{B}{A}{Down}{Up}{Right}{Left}


// ***************************************************************************************
//
// Group 8 (Sound)
//
// ***************************************************************************************

GROUP 8 Sound
    FUNCTION 1 Reset Sound
        SNDResetAll();
    DOCUMENTATION
        Reset the sound system.
        This empties all channel queues and silences all channels immediately.

    FUNCTION 2 Reset Channel
        *DERROR = SNDResetChannel(*DPARAMS);
    DOCUMENTATION
        Reset the sound channel specified in \Param{0}.

    FUNCTION 3 Beep
        SNDStartup();
    DOCUMENTATION
        Play the startup beep immediately.

    FUNCTION 4 Queue Sound
        *DERROR = SNDPlay(DPARAMS[0],DSPGetInt16(DCOMMAND,5),DSPGetInt16(DCOMMAND,7),DSPGetInt16(DCOMMAND,9),DPARAMS[7]);
    DOCUMENTATION
        Queue a sound.
        Refer to Section \#\ref{sound} "Sound" for details.
        \newline
        \ParamsBytes{Queue Sound Parameters}{Chan}{Frq hi}{Frq lo}{Dur lo}
                                            {Dur hi}{Sld lo}{Sld hi}{Source}

    FUNCTION 5 Play Sound
        *DERROR = SFXPlay(DPARAMS[0],DPARAMS[1]);
    DOCUMENTATION
        Play the sound effect specified in \Param{1}
        on the channel specified in \Param{0} immediately, clearing the channel queue.

    FUNCTION 6 Sound Status
        i1 = SNDGetNoteCount(DPARAMS[0]);
        DPARAMS[0] = i1 & 0xFF;
        *DERROR = (i1 < 0) ? 1 : 0;
    DOCUMENTATION
        Deposit in \Param{0} the number of notes outstanding before silence
        in the queue of the channel specified in \Param{0},
        including the current playing sound, if any.


// ***************************************************************************************
//
// Group 9 (Turtle Graphics)
//
// ***************************************************************************************

GROUP 9 ,0 Turtle Graphics
    FUNCTION 1 Turtle Initialise
        TTLInitialise(DPARAMS[0]);
    DOCUMENTATION
        Initialise the turtle graphics system.
        \Param{0} is the sprite number to use for the turtle,
        as the turtle graphics system “adopts” one of the sprites.
        The icon is not currently re-definable, and initially the turtle is hidden.

    FUNCTION 2 Turtle Turn
        TTLRotate(DSPGetInt16(DCOMMAND,4));
    DOCUMENTATION
        Turn the turtle right by \Param{0}\Param{1} degrees. Show if hidden.

    FUNCTION 3 Turtle Move
        TTLMove(DSPGetInt16(DCOMMAND,4),DCOMMAND[6],DCOMMAND[7]);
    DOCUMENTATION
        Move the turtle forward by \Param{0}\Param{1} degrees, drawing in colour \Param{2},
        pen down flag in \Param{3}. Show if hidden.

    FUNCTION 4 Turtle Hide
        TTLHide();
    DOCUMENTATION
        Hide the turtle.

    FUNCTION 5 Turtle Home
        TTLHome();TTLUpdate();
    DOCUMENTATION
        Move the turtle to the home position (in the center, pointing upward).


// ***************************************************************************************
//
// Group 10 (UExt)
//
// ***************************************************************************************

GROUP 10 UExt I/O
    FUNCTION 1 UExt Initialise
        IOInitialise();
    DOCUMENTATION
        Initialise the UExt I/O system
        \newline TODO: explain this function and any parameters

    FUNCTION 2 Write GPIO
        *DERROR = IOWrite(DPARAMS[0],DPARAMS[1] != 0);
    DOCUMENTATION
        (P0,P1)
        \newline TODO: explain this function and any parameters

    FUNCTION 3 Read GPIO
        *DERROR = IORead(DPARAMS[0],&b1);
        DPARAMS[0] = b1 ? 0xFF:0;
    DOCUMENTATION
        P0 = GPIO(P0)
        \newline TODO: explain this function and any parameters

    FUNCTION 4 Set Port Direction
        *DERROR = IOSetDirection(DPARAMS[0],DPARAMS[1]);
    DOCUMENTATION
        P0 to P1
        \newline TODO: explain this function and any parameters

    FUNCTION 5 Write I2C
        *DERROR = IOI2CWriteRegister(DPARAMS[0],DPARAMS[1],DPARAMS[2]);
    DOCUMENTATION
        (P0,P1,P2)
        \newline TODO: explain this function and any parameters

    FUNCTION 6 Read I2C
        *DERROR = IOI2CReadRegister(DPARAMS[0],DPARAMS[1],&u2);
        DPARAMS[0] = u2;
    DOCUMENTATION
        P0 = (P0,P1)
        \newline TODO: explain this function and any parameters

    FUNCTION 7 Read GPIO Analog
        *DERROR = IOReadAnalogue(DPARAMS[0],&u3);
        DPARAMS[0] = u3 & 0xFF;DPARAMS[1] = (u3 >> 8);
    DOCUMENTATION
        P1P0 = GPIOAnalogue(P0)
        \newline TODO: explain this function and any parameters
